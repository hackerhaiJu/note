# 分布式事务（国内开源的 ByteTCC、Himly、TCC-transaction）

### 1、分布式涉及的异常问题
```java
 机器宕机、网络异常、消息丢失、消息乱序、数据错误、不可靠的TCP、存储数据丢失、其他异常等等
```
### 2、CAP定理
```java
这三个指标不可能同时做到。这个结论就叫做 CAP 定理。
C:一 致 性（多个A子系统中修改了值，B系统中也能访问到修改的值，就叫数据一致性）
A:可 用 性（只要用户发送请求，服务器就必须给出回应）
P:分区容错（分布式系统放在多个子网络中，每个子网络就叫一个区，可能因为各种原因导致通信失败）
一致性和可用性，为什么不可能同时成立？答案很简单，因为可能通信失败（即出现分区容错）

分区容错发生在分布式系统内部互访通信，是指分布式网络中部分网络不可用，但系统依然正常对外提供服务。
比如：北京的订单系统，访问上海的库存系统，可能导致失败。如果发生失败，就要在A和C之间做出选择。
要么停止系统进行错误恢复，要么继续服务但是降低一致性，所以说只能保证AP或CP。

2PC跨库事务（JTA/XA）
开源框架（atomikos）实现垮库事务
1，导入jar包 
2，连接池基本属性
3，连接路径账号密码
4，让atomikos代理Jdbc 
5，创建一个全场事务
6，开启事务，编译sql
7，预提交
8，判断 如果 没有异常 就提交事务，则回滚事务，同时atomikos 如果提交 失败的话 它有重试的 还有记录日志的 功能 可以手动 提交(在实际开发中用的并不多)
```
### 3、BASE理论
```java
Basically Available（基本可用）
Soft state（软状态）
Eventually consistent（最终一致性）
BASE理论是对CAP中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）
```
### 4、基于可靠消息的最终一致性方案（异步确保型）
```java
1、上游服务，发送消息到可靠消息服务，可靠消息服务保存消息状态为“待确认”
2、上游服务执行自己本地数据库的操作，事务成功修改可靠消息服务中的数据，事务失败找到可靠消息服务的数据删除
3、如果此时消息服务中状态为“已发送”，就将消息发送给MQ（修改和发送必须在一个方法里面，并且开启本地事务）
4、下游服务等着从MQ消费就好，如果消费成功就返回来通知消息服务，并且将消息的状态修改为“已完成”

如何保证上游服务对消息的100%可靠投递
新开一个定时后台线程，对可靠消息服务中的数据不停的进行监控，如果有消息一直为“待确认”，那么就去调用上游服务，去确认这条数据有没有执行成功。

如何保证下游服务对消息的100%可靠接收
在可靠服务中新开一个定时后台线程，对可靠服务中的数据不停的进行监控，如果有消息为“已发送”始终没有变成“已完成”，那么就会认为是出现了问题，就去调用下游服务，来查看下游的服务是否消费成功

```
### 5、TCC事务补偿性方案（基于2PC协议的两阶段提交）  同步
```java
核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作
Try: 阶段主要是对业务系统做检测及资源预留
Confirm: 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会
         出错的。即：只要Try成功，Confirm一定成功
Cancel: 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放
每一个服务里面都有一个事务活动日志磁盘文件或者数据库，会保存下来分布式事务运行的各个阶段和状态。如果出现问题
或者出现了故障，都可以在这里面找到
```
### 6、最大努力通知型方案


### 7、 基于 KV 存储的队列支持的高可用降级方案
```java
上游服务：
  自己封装一个MQ可靠消息服务，自己封装一个MQ客户端组件与故障感知，如果在消息进行投递的时候，多次没有得到回应，那么就启动降级。
解决：可以采用 Redis来进行存储，Redis也支持队列。均匀hash算法来均匀的存储在N个队列中
问题：
  不能对同一个key里面加入大量的value值
  不能往少数key对应的数据结构中写入数据，否则会导致热key产生
通过Zookeeper来触发一个降级开发，让整个MQ这块全部降级
下游服务：
  下游服务消费 MQ 也是通过自行封装的组件来做的，此时那个组件如果从 ZK 感知到降级开关打开了，首先会判断自己是  
  否还能继续从 MQ 消费到数据？如果不能了，就开启多个线程，并发的从 KV 存储的各个预设好的上百个队列中不断的获
  取数据。
自动恢复：
  如果降级开关打开之后，自行封装的组件需要开启一个线程，每隔一段时间尝试给 MQ 投递一个消息看看是否恢复了。
如果 MQ 已经恢复可以正常投递消息了，此时就可以通过 ZK 关闭降级开关，然后可靠消息服务继续投递消息到 MQ，下游服务在确认 KV 存储的各个队列中已经没有数据之后，就可以重新切换为从 MQ 消费消息。
```