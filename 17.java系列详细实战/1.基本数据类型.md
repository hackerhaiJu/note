# 数据类型

## 1. 8大基本数据类型

在java中有8种基本数据类型，而8种基本数据类型对应的了8种包装类型，包装类型的目的就是为了将基本数据类型包装成为 **对象**，其中java内部也提供了自动的 **拆箱和装箱**

| 基本数据类型 | 字节 | 包装类型 | 缓存池          |
| ------------ | ---- | -------- | --------------- |
| boolean      | 1    | Boolean  | true、false     |
| byte         | 1    | Byte     | 所有byte的值    |
| char         | 2    | Char     | \u0000 ~ \u007F |
| short        | 2    | Short    | -127 ~ 128      |
| int          | 4    | Integer  | -127 ~ 128      |
| float        | 4    | Float    |                 |
| long         | 8    | Long     |                 |
| double       | 8    | Double   |                 |

## 2. 拆箱装箱

> 自动拆箱和自动装箱：java内部实现了 Integer和int 相互自动转换，不需要进行new来new去，可以相互直接赋值

```java
Integer a = 1;
int b = a;
a = b;
```

## 3. 缓存池

缓存池是指，java内部在基本数据类型比较常用的一段数据间设置的缓存数据，这样的目的可以避免频繁的创建对象因此而占用空间

- new Integer(123) 每次都会新建一个对象
- Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。

```java
Integer x = new Integer(123);
Integer y = new Integer(123);
System.out.println(x == y);    // false
Integer z = Integer.valueOf(123);
Integer k = Integer.valueOf(123);
System.out.println(z == k);   // true
```

valueOf()的实现非常的简单，先判断值是否在需要缓存的区间中，如果不存在就直接创建新的对象

```java
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```

```java
private static class IntegerCache {
        static final int low = -128;
        static final int high;
        static final Integer cache[];

        static {
            // 缓存最大值
            int h = 127;
            //获取配置文件中进行配置缓存最大值
            String integerCacheHighPropValue =
                sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
            if (integerCacheHighPropValue != null) {
                try {
                    //将string转换为int
                    int i = parseInt(integerCacheHighPropValue);
                    //获取到的配置文件和默认值谁更大
                    i = Math.max(i, 127);
                    //获取到最小的数据
                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
                } catch( NumberFormatException nfe) {
                    // If the property cannot be parsed into an int, ignore it.
                }
            }
            high = h;
			//构建缓存池
            cache = new Integer[(high - low) + 1];
            int j = low;
            for(int k = 0; k < cache.length; k++)
                cache[k] = new Integer(j++);

            // range [-128, 127] must be interned (JLS7 5.1.7)
            assert IntegerCache.high >= 127;
        }

        private IntegerCache() {}
    }
```

