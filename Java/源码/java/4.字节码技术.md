# jVM字节码技术

## 1. Class文件加载过程

Class文件的加载一共分为5个步骤：

### 1.1 加载

将class文件的二进制文件加载到方法区中进行存储，在加载时会在内存中创建一个**java.lang.Class**的对象，虚拟机规范中没有规定Class对象存放在哪里，hotspot虚拟机存放在方法区当中，用来封装类在方法区内的数据结构

### 1.2 连接

连接阶段又分为3个小步骤

#### 验证

验证class文件的格式是否是符合虚拟机的标准

#### 准备

为类的静态变量分配内存空间并且赋值默认值，分配的地方是在方法区当中

#### 解析

主要是将类中的符号引用转变为直接引用

### 1.3 初始化

在class进行初始化时有7种方式进行触发：

- 当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化方式
- 当调用类的静态方法，即当使用了字节码invokestatic指令
- 使用某个接口的静态变量，即使用了字节码getstatic、putstatic指令
- 当使用java.lang.reflect包中的方法反射类的方法时
- 当初始化子类时，必须先初始化父类
- java虚拟机启动时被标明启动类的类
- jdk1.7开始提供的动态语言支持（例如：动态代理）

除了上述情况为主动使用外，其他情况均属于被动使用，被动使用不会引起类的初始化，只会加载类。可以使用 -**XX:+ThraceClassLoading** 来追踪类的加载信息并且打印出来。

**注意：-XX:+\<Option>：表示开启，-XX:-\<Option>：表示关闭，这是对应boolean类型的参数值，-XX:\<Option>=\<Value>，表示赋值的形式**

#### 实例1

```java
class MyTest {
  //MyTest2.str的常量存放到了MyTest的常量池中，之后MyTest与MyTest2没有任何关系，甚至将MyTest2编译后的字节码文件删除都可以执行
  public static void main() {
    System.out.println(MyTest1.str);
    System.out.println(MyTest2.str);
  }
  
}

class MyTest1 {
  public static String str = "hello mytest2"
    
    static {
    	System.out.println("mytest1 static block");
  }
}

class MyTest2 {
  public static final String str = "hello mytest2"
    
    static {
    	System.out.println("mytest2 static block");
  }
}
```

**结论：常量在编译阶段会存入到调用这个常量的方法所在的类的常量池中，本质上，调用类并没有直接引用到定义类常量的类，因此并不会直接触发定义常量类的初始化**

#### 实例2

```java
class MyTest {

  public static void main() {
    System.out.println(MyTest1.str);
  }
  
}

class MyTest1 {
  public static String str = UUID.randomUUID().toString();
    
    static {
    	System.out.println("mytest1 static block");
  }
}
```

**结论：被动触发了MyTest1类进行实例化了（只能在运行期中进行确定），编译期能够确定下来才会放到使用类的常量池当中**

#### 实例3

```java
class MyTest {

  public static void main() {
    MyTest1[] test = new MyTest1[1];
  }
  
}

class MyTest1 {
    static {
    	System.out.println("mytest1 static block");
  }
}
```

**结论：数组的类型是虚拟机在运行期帮我们创建的一个类型，类型为 [L 开头的类型，二维数组就是 [[L 开头的类型；**

#### 实例4

```java
class MyTest {

  public static void main() {
    System.out.println(MyTest2.b);
  }
  
}

interface MyTest1 {
    public static int a = 5;
}

interface MyTest2 extends MyTest1 {
    public static int b = 6;
}
```

**结论：当一个接口在初始化时，并不要求其父接口都完成了初始化；对于接口来说，成员变量都是常量**

### 1.4 使用



### 1.5 卸载





## 助记符

java中助记符通过 **rt.jar包中的 com.sun.org.apache.bcel.internal.generic 类来进行操作的**

- ldc：表示将int、float或者是String类型的常量值从常量池中推送到桟顶
  - bipush：表示将单字节（-128 - 127）的常量值从常量池推送到栈顶
  - sipush：表示将一个短整形（-32768 - 32767）常量值推送至桟顶
  - Iconst_1：将int类型值为1推送至栈顶（iconst_1 ~ iconst_5），虚拟机认为1 - 5最常用，超过6又会使用bipush。范围是-1 ～ 5，-1就是iconst_m1
- invokestatic：调用静态方法
- getstatic：获取到静态属性值
- anewarray：创建一个引用类型（类、接口、数组）的数组，并将其引用值推送至栈顶
- newarray：创建一个指定的原始类型（int、float、char）的数组，并且将其引用值推送至桟顶