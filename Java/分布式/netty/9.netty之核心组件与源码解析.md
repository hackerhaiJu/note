# 一、netty核心类

- Channel：netty定义的管道，负责底层通讯并关联netty组件
- ChannelHandler：管道处理器
- ChannelPipeline：管道流水处理器，主要用于对一个请求的多个处理
- ChannelHandlerContext：管道处理器的上下文，通过上下文来调用 **ChannelHandler**
- EventLoop：用于对应具体的事件循环，每个 channel 对象都会对应一个 EventLoop，每个EventLoop又对应一个 Selector，用于循环处理
- EventLoopGroup：用于管理多个 EventLoop，用于将 channel 跟 EventLoop进行关联
- BootStrap

## 1. Channel

![1666073280657](https://cdn.jsdelivr.net/gh/hackerhaiJu/note-picture@main/note-picture/1666073280657.png)

### AttributeMap

父接口持有属性的能力，通过 `attr` 方法获取属性，`hasAttr` 判断属性是否存在

```java
public interface AttributeMap {
    <T> Attribute<T> attr(AttributeKey<T> key);
    <T> boolean hasAttr(AttributeKey<T> key);
}
```

### ChannelOutboundInvoker

父接口线程出栈执行器，**Channel** 出栈执行器，具备底层通讯能力，可以看到 **Netty** 的操作都是异步的，方法调用都是返回 **Future** 或者 **Promise** 对象，当方法完成后会通过 **Future** 或 **Promise** 收到通知

```java
public interface ChannelOutboundInvoker {
    //绑定接口
    ChannelFuture bind(SocketAddress localAddress);
    ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise);
    //建立连接
    ChannelFuture connect(SocketAddress remoteAddress);
    ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress); 	     ChannelFuture connect(SocketAddress remoteAddress, ChannelPromise promise);
    ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise);
    //断开关闭连接
    ChannelFuture disconnect();
    ChannelFuture disconnect(ChannelPromise promise);
    ChannelFuture close();
    ChannelFuture close(ChannelPromise promise);
    //从EventLoop注销
    ChannelFuture deregister();
    ChannelFuture deregister(ChannelPromise promise);
    //设置关心的 I/O 事件为 OP_READ
    ChannelOutboundInvoker read();
    //写数据
    ChannelFuture write(Object msg);
    ChannelFuture write(Object msg, ChannelPromise promise);
    ChannelOutboundInvoker flush();
    ChannelFuture writeAndFlush(Object msg, ChannelPromise promise);
    ChannelFuture writeAndFlush(Object msg);
    //构造future/promise
    ChannelPromise newPromise();
    ChannelProgressivePromise newProgressivePromise();
    ChannelFuture newSucceededFuture();
    ChannelFuture newFailedFuture(Throwable cause);
    ChannelPromise voidPromise();
}
```

### Comparable

父接口提供管道之间的比较，泛型为 **Channel**

```java
public interface Comparable<T> {
    public int compareTo(T o);
}
```

### Channel

**Channel** 接口本身提供 **通道状态** 和 **Netty组件** 的关联关系

```java
public interface Channel extends AttributeMap, ChannelOutboundInvoker, Comparable<Channel> {
    //管道的Id
    ChannelId id();
    //当前管道 Channel注册的EventLoop
    EventLoop eventLoop();
    //被ServerSocketChannel接受的SocketChannel将返回ServerSocketChannel作为其parent
    Channel parent();
    //返回管道的配置对象
    ChannelConfig config();
    //是否打开
    boolean isOpen();
    //是否注册到 EventLoop
    boolean isRegistered();
    //是否已经激活（建立连接）
    boolean isActive();
    ChannelMetadata metadata();
    //管道的本地地址
    SocketAddress localAddress();
    //管道连接的远程地址
    SocketAddress remoteAddress();
    //返回 Future当管道关闭后会收到通知
    ChannelFuture closeFuture();
    //是否可以执行写操作
    boolean isWritable();
    //当isWritable返回true时，返回可写字节数，否则返回0
    long bytesBeforeUnwritable();
    //当前isWritable返回false时，返回可读字节数，否则返回0
    long bytesBeforeWritable();
    //跟底层进行关联时，并不是由 Channel 进行而是由 Channel.Unsafe进行关联操作
    Unsafe unsafe();
    //返回管道处理流水线
    ChannelPipeline pipeline();
    //ByteBuf分配器
    ByteBufAllocator alloc();
    //读取管道
    @Override
    Channel read();
    //刷新管道
    @Override
    Channel flush();
}
```

### Channel.Unsafe

**Channel** 接口里面声明的内部接口，是 **Netty** 自己使用的，不会被用户代码直接调用，它负责真正的底层通讯

```java
interface Unsafe {
        RecvByteBufAllocator.Handle recvBufAllocHandle();
    //本地地址
        SocketAddress localAddress();
    //远程地址
        SocketAddress remoteAddress();
    //注册到 EventLoop上
        void register(EventLoop eventLoop, ChannelPromise promise);
    //绑定
        void bind(SocketAddress localAddress, ChannelPromise promise);
    //开启连接
        void connect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise);
    //断开连接
        void disconnect(ChannelPromise promise);
    //关闭
        void close(ChannelPromise promise);
    //强行关闭
        void closeForcibly();
    //注销
        void deregister(ChannelPromise promise);
    //开启一个读操作
        void beginRead();
    //写操作
        void write(Object msg, ChannelPromise promise);
    //刷新
        void flush();
    //返回一个空的 Promise
        ChannelPromise voidPromise();
        ChannelOutboundBuffer outboundBuffer();
    }
```

客户端使用 **NioByteUnsafe**，服务端使用 **NioMessageUnsafe**

![image-20241025105216730](images/image-20241025105216730.png)



### ServerSocketChannel（服务端）

标记接口，继承至 **Channel** 接口，通过 **ServerChannel.aceept()** 来创建一个 **Channel**，实现的例子就是 **NioServerSocketChannel**

![1667210989835](https://cdn.jsdelivr.net/gh/hackerhaiJu/note-picture@main/note-picture/1667210989835.png)

```java
public interface ServerSocketChannel extends ServerChannel {
    //配置对象
    @Override
    ServerSocketChannelConfig config();
    //本地地址
    @Override
    InetSocketAddress localAddress();
    //远程连接地址
    @Override
    InetSocketAddress remoteAddress();
}
```

### SocketChannel（客户端）

客户端管道对象

![1667211223808](https://cdn.jsdelivr.net/gh/hackerhaiJu/note-picture@main/note-picture/1667211223808.png)

```java
public interface SocketChannel extends DuplexChannel {
    @Override
    ServerSocketChannel parent();

    //配置对象
    SocketChannelConfig config();
    //本地地址
    InetSocketAddress localAddress();
    //远程地址
    InetSocketAddress remoteAddress();
}
```



## 2. ChannelHandler

 **ChannelHandler** 接口提供了ChannelHandler被 **ChannelHandlerContext** 加入或移除时的钩子 

```java
public interface ChannelHandler {
    //将其加入到 Context上下文中
    void handlerAdded(ChannelHandlerContext ctx) throws Exception;
    //从上下文中移除
    void handlerRemoved(ChannelHandlerContext ctx) throws Exception;
    //捕获异常
    void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception;
    
    @Inherited
    @Documented
    @Target(ElementType.TYPE)
    @Retention(RetentionPolicy.RUNTIME)
    @interface Sharable {
        // no value
    }
}
```

**ChannelHandler** 又分为入栈和出栈，**ChannelInboundHandler、ChannelOutboundHandler**

### 2.1 ChannelOutboundHandler

```java
public interface ChannelOutboundHandler extends ChannelHandler {
    //当bind操作时触发
    void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) throws Exception;

    //当connect操作时触发
    void connect(
            ChannelHandlerContext ctx, SocketAddress remoteAddress,
            SocketAddress localAddress, ChannelPromise promise) throws Exception;

    //断开disconnect时触发
    void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception;

    //关闭close操作时触发
    void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception;

    //从EventLoop移除时触发
    void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception;

    //当读取时触发
    void read(ChannelHandlerContext ctx) throws Exception;

    //当写操作时触发
    void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception;

    //当刷新操作时触发
    void flush(ChannelHandlerContext ctx) throws Exception;
}
```

### 2.2 ChannelInboundHandler

```java
public interface ChannelInboundHandler extends ChannelHandler {

    //管道注册到 EventLoop时触发
    void channelRegistered(ChannelHandlerContext ctx) throws Exception;

    //管道从 EventLoop移除时触发
    void channelUnregistered(ChannelHandlerContext ctx) throws Exception;

    //管道激活后触发（如连接）
    void channelActive(ChannelHandlerContext ctx) throws Exception;

    //Channel未激活后触发（如连接关闭）
    void channelInactive(ChannelHandlerContext ctx) throws Exception;

    //当Channel读取到数据后触发
    void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception;

    //当Channel读取完成后触发
    void channelReadComplete(ChannelHandlerContext ctx) throws Exception;

    //用户自定义事件触发
    void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception;

    //管道的isWritable发生变化后触发
    void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception;

    //发生异常时触发
    @Override
    @SuppressWarnings("deprecation")
    void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception;
}
```

**ChannelInboundHandler、ChannelOutboundHandler** 中的方法子类不可能都实现，所以就提供了 **ChannelInboundHandlerAdapter、ChannelOutboundHandlerAdapter** 两个类将所有方法都进行了默认实现，用户只需要自己实现对应的方法就行

```java
public class ChannelInboundHandlerAdapter extends ChannelHandlerAdapter implements ChannelInboundHandler {

    //方法名都一一对应，其中Skip用于标识方法是否需要跳过
    @Skip
    @Override
    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {
        ctx.fireChannelRegistered();
        
    }
    
    
    @Skip
    @Override
    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {
        ctx.fireChannelUnregistered();
    }
}
```

如果用户需要同时处理 **入栈、出栈** 的方法，可以通过 **ChannelDuplexHandler** 实现

```java
public class ChannelDuplexHandler extends ChannelInboundHandlerAdapter implements ChannelOutboundHandler {
    @Skip
    @Override
    public void bind(ChannelHandlerContext ctx, SocketAddress localAddress,
                     ChannelPromise promise) throws Exception {
        ctx.bind(localAddress, promise);
    }
    // ... 省略其他ChannelOutboundHandler方法实现
}
```

## 3. ChannelPipeline

有了ChannelHandler之后存在以下几个问题：

- 单个 **ChannelHandler** 无法处理整个网络请求，往往一个 **ChannelHandler** 只会处理一次请求的部分业务。比如编解码和业务处理往往是不同的Handler。
- 当存在多个 **ChannelHandler** 的情况下，如何编排 **ChannelHandler**
- Channel接口继承了 **ChannelOutboundInvoker** 接口，可以触发 **ChannelOutboundHandler出栈Handler** 执行，如何触发入栈Handler执行。

**ChannelPipeline** 就是为了解决这些问题而生的，他不但继承了ChannelOutboundInvoker接口可以触发出栈事件，同时继承了 **ChannelInboundInvoker** 可以触发入栈事件。这些 **fireXXX** 与 **ChannelInboundHandler** 的方法一一对应

```java
public interface ChannelPipeline
        extends ChannelInboundInvoker, ChannelOutboundInvoker, Iterable<Entry<String, ChannelHandler>> {

    //将 Handler 添加到队首
    ChannelPipeline addFirst(String name, ChannelHandler handler);

    ChannelPipeline addFirst(EventExecutorGroup group, String name, ChannelHandler handler);

    //添加到队尾
    ChannelPipeline addLast(String name, ChannelHandler handler);

    ChannelPipeline addLast(EventExecutorGroup group, String name, ChannelHandler handler);

    //添加到某个 Handler之前
    ChannelPipeline addBefore(String baseName, String name, ChannelHandler handler);

    ChannelPipeline addBefore(EventExecutorGroup group, String baseName, String name, ChannelHandler handler);

    //添加到某个 Handler之后
    ChannelPipeline addAfter(String baseName, String name, ChannelHandler handler);

    ChannelPipeline addAfter(EventExecutorGroup group, String baseName, String name, ChannelHandler handler);

    //添加多个到队首
    ChannelPipeline addFirst(ChannelHandler... handlers);

    ChannelPipeline addFirst(EventExecutorGroup group, ChannelHandler... handlers);

    //添加多个到队尾
    ChannelPipeline addLast(ChannelHandler... handlers);

    ChannelPipeline addLast(EventExecutorGroup group, ChannelHandler... handlers);

    //移除某个 handler
    ChannelPipeline remove(ChannelHandler handler);

    ChannelHandler remove(String name);

    <T extends ChannelHandler> T remove(Class<T> handlerType);

    //移除队首
    ChannelHandler removeFirst();

    //移除队尾
    ChannelHandler removeLast();

    //替换
    ChannelPipeline replace(ChannelHandler oldHandler, String newName, ChannelHandler newHandler);

    ChannelHandler replace(String oldName, String newName, ChannelHandler newHandler);

    <T extends ChannelHandler> T replace(Class<T> oldHandlerType, String newName,
                                         ChannelHandler newHandler);

    //返回队首
    ChannelHandler first();

    //返回队首的上下文
    ChannelHandlerContext firstContext();

    //返回队尾
    ChannelHandler last();

    //队尾的上下文
    ChannelHandlerContext lastContext();

    //获取某个handler
    ChannelHandler get(String name);

    <T extends ChannelHandler> T get(Class<T> handlerType);

    //获取某个handler的上下文
    ChannelHandlerContext context(ChannelHandler handler);

    //对应名称的上下文
    ChannelHandlerContext context(String name);

    ChannelHandlerContext context(Class<? extends ChannelHandler> handlerType);

    //返回管道
    Channel channel();

    //获取所有handler的名称
    List<String> names();

    //转换成map
    Map<String, ChannelHandler> toMap();

    /**
     * 下面是覆写了触发入栈方法的实现
     */
    @Override
    ChannelPipeline fireChannelRegistered();

    @Override
    ChannelPipeline fireChannelUnregistered();

    @Override
    ChannelPipeline fireChannelActive();

    @Override
    ChannelPipeline fireChannelInactive();

    @Override
    ChannelPipeline fireExceptionCaught(Throwable cause);

    @Override
    ChannelPipeline fireUserEventTriggered(Object event);

    @Override
    ChannelPipeline fireChannelRead(Object msg);

    @Override
    ChannelPipeline fireChannelReadComplete();

    @Override
    ChannelPipeline fireChannelWritabilityChanged();

    @Override
    ChannelPipeline flush();
}
```

在创建 **Channel** 管道时，例如：**AbstractChannel** 中启动 **pipline** 实际创建的是 **DefaultChannelPipline** 进行处理，在添加到 **pipeline** 时实际是以 **DefaultChannelHandlerContext** 类型包装了一层，在 **pipeline** 进行传递的是 **ChannelHandlerContext** 的类型

## 4. ChannelHandlerContext

 **ChannelHandlerContext** 是一个上下文对象，持有 **Channel/ChannelHandler/ChannelPipeline** 重要组件。同时它也继承了 **ChannelInboundInvoker** 和 **ChannelOutboundInvoker**，可以触发入栈和出栈事件；而 **ChannelHandlerContext** 的链表结构是在 **AbstractChannelHandlerContext** 中体现

```java
abstract class AbstractChannelHandlerContext implements ChannelHandlerContext, ResourceLeakHint {
    //下一个节点
    volatile AbstractChannelHandlerContext next;
    //前置节点
    volatile AbstractChannelHandlerContext prev;
    //用于标识 @Skip 注解是否需要跳过的方法
    private final int executionMask;
    
	//用于寻找是否需要执行的 ChannelHandler
    private AbstractChannelHandlerContext findContextInbound(int mask) {
    	AbstractChannelHandlerContext ctx = this;
    	EventExecutor currentExecutor = executor();
        do {
            ctx = ctx.next;
            // 判断是否要跳过下一个AbstractChannelHandlerContext
        } while (skipContext(ctx, currentExecutor, mask, MASK_ONLY_INBOUND));
        return ctx;
    }
}
```

## 5. EventLoop

 **EventLoop **译为 **事件循环**，事件驱动的编程模型都有 **EventLoop** 这个概念（如javascript）。Netty的EventLoop可以认为是 **EventLoopGroup** 的一个特殊实现，它是一个线程构成的线程池服务。 

![1667205647926](https://cdn.jsdelivr.net/gh/hackerhaiJu/note-picture@main/note-picture/1667205647926.png)

 **NioEventLoop** 是对于JDK NIO的事件循环处理，**每个NioEventLoop都持有一个Selector**，处理 **Selector** 上的 **SelectionKey** 事件。 

```java
public final class NioEventLoop extends SingleThreadEventLoop {
   
    private Selector selector;
    
    protected void run() {
        int selectCnt = 0;
        for (;;) {
            //轮询是否有事件发生
            select();
            //处理事件
            processSelectedKeys();
            // 执行任务
            runAllTasks();
        }
    }
}
```

父类  **SingleThreadEventExecutor** 绑定线程，并持有任务队列

```java
public abstract class SingleThreadEventExecutor extends AbstractScheduledEventExecutor implements OrderedEventExecutor {
    // 任务队列
    private final Queue<Runnable> taskQueue;
    // EventLoop绑定的线程
    private volatile Thread thread;
    // JDK Executor 单线程提供服务
    private final Executor executor;
}
```

## 6. EventLoopGroup

**EventLoopGroup** 管理多个 **EventLoop** ，主要负责选择 **EventLoop** 并注册 **Channel** 到对应的 **EventLoop**上。接口作用和方法职责在javadoc上很清楚，两个 **register** 方法的目的都是一样的，将Channel注册到EventLoop上

![image-20241024142749196](images/image-20241024142749196.png)

```java
public interface EventLoopGroup extends EventExecutorGroup {
    /**
     * 返回一个 EventLoop 对象用于跟channel进行注册，每一个channel对象都会对应一个 EventLoop 用于进行数据的处理
     */
    @Override
    EventLoop next();

    /**
     * 注册channel跟EventLoop进行关联
     */
    ChannelFuture register(Channel channel);

    /**
     * 注册一个 ChannelPromise 对象实际是对 channel 进行包装的，可以添加监听器等功能
     */
    ChannelFuture register(ChannelPromise promise);
}
```



# 二、源码解析

源码版本为：**4.1.78.Final**

## 1. 服务端启动流程

![image-20210309144617107](images/image-20210309144617107-9672399.png)

先从一个简单的例子开始解析：

- 创建ServerBootstrap服务端的启动器
- 指定主服务的线程池和处理线程池
  - 根据上面的处理模型：bossGroup用于处理客户端的连接，并且线程池中有任务来处理客户端的连接请求，然后将对应的channel管道又注册到workGroup线程中
  - 然后workGroup的任务也进行循环处理将对应的读写事件又交给handler进行处理
- 配置channel管道应该使用到类型
- 配置对应tcp的一些参数
- 指定子线程中的处理类
- 绑定端口，进行阻塞

```java
public void bind(int port) {
    NioEventLoopGroup bossGroup = new NioEventLoopGroup();
    NioEventLoopGroup workGroup = new NioEventLoopGroup();
    try {
        ServerBootstrap serverBootstrap = new ServerBootstrap();
        serverBootstrap
            .group(bossGroup, workGroup)
            //选择服务器channel的实现
            .channel(NioServerSocketChannel.class)
            .option(ChannelOption.SO_BACKLOG, 1024)
            .childHandler(new ChildChannelHandler());
        ChannelFuture channelFuture = serverBootstrap.bind(port).sync();
        //等待服务端监听端口关闭
        channelFuture.channel().closeFuture().sync();
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        bossGroup.shutdownGracefully();
        workGroup.shutdownGracefully();
    }
}
```

### 1.1 ServerBootstrap

ServerBootstrap实现AbstractBootstrap并且指定了泛型内部的类型；**AbstractBootstrap** 其中只保存处理客户端连接请求的管道配置，而**ServerBootstrap** 则保存当客户端发送对应的读写事件时的处理管道配置

```java
public abstract class AbstractBootstrap<B extends AbstractBootstrap<B, C>, C extends Channel> implements Cloneable {
  //boss线程组，用于处理连接事件
    volatile EventLoopGroup group;
    @SuppressWarnings("deprecation")
    //管道工厂类，通过工厂来创建管道的类型，默认工厂类ReflectiveChannelFactory
    private volatile ChannelFactory<? extends C> channelFactory;
    private volatile SocketAddress localAddress;
    // 父级启动器配置属性
    private final Map<ChannelOption<?>, Object> options = new LinkedHashMap<ChannelOption<?>, Object>();
  	// 自定义的属性
    private final Map<AttributeKey<?>, Object> attrs = new ConcurrentHashMap<AttributeKey<?>, Object>();
  	// 主服务的管道处理类
    private volatile ChannelHandler handler;
}
```

创建时指定事件循环组，配置对应的相关配置信息给options中添加对应的数据配置（[Netty常用Option配置说明](https://www.cnblogs.com/acestart/p/14801869.html)）

```java
public class ServerBootstrap extends AbstractBootstrap<ServerBootstrap, ServerChannel> { 
		//子管道的配置属性
    private final Map<ChannelOption<?>, Object> childOptions = new LinkedHashMap<ChannelOption<?>, Object>();
    //子管道的属性
    private final Map<AttributeKey<?>, Object> childAttrs = new ConcurrentHashMap<AttributeKey<?>, Object>();
    //管道配置类，通过 ServerBootstrapConfig可以获取到 ServerBootstrap中绑定的属性
    private final ServerBootstrapConfig config = new ServerBootstrapConfig(this);
    //子管道的事件循环组
    private volatile EventLoopGroup childGroup;
    //子管道的处理器
    private volatile ChannelHandler childHandler;
  
  	/**
     * 创建事件循环组，默认可以使用 NioEventLoopGroup进行创建，指定主线程池以及子线程池
     * childGroup：用于指定当客户端发送读写事件时进行处理的线程池
     */
  	public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup) {
        super.group(parentGroup);
        if (this.childGroup != null) {
            throw new IllegalStateException("childGroup set already");
        }
        this.childGroup = ObjectUtil.checkNotNull(childGroup, "childGroup");
        return this;
    }
  
  	public <T> B option(ChannelOption<T> option, T value) {
        ObjectUtil.checkNotNull(option, "option");
        synchronized (options) {
            if (value == null) {
                options.remove(option);
            } else {
                options.put(option, value);
            }
        }
        return self();
    }
}
```

管道和配置相关的信息绑定好了就可以绑定对应的端口启动服务了，调用 **doBind()** 方法进行管道的启动

- initAndRegister()：方法创建对应类型的channel管道，对channel管道进行初始化的配置，将管道注册到对应的bossGroup中
- 绑定完成后执行对应的handler的bind()方法

```java
private ChannelFuture doBind(final SocketAddress localAddress) {
      /**
       * 创建一个 ChannelFuture 任务用于异步执行的任务，初始化并且进行管道（channel）的注册
       */
      final ChannelFuture regFuture = initAndRegister();
      //获取到管道
      final Channel channel = regFuture.channel();
      if (regFuture.cause() != null) {
          return regFuture;
      }
      //判断初始化管道任务是否已经完成
      if (regFuture.isDone()) {
          // At this point we know that the registration was complete and successful.
          ChannelPromise promise = channel.newPromise();
          //执行端口的绑定操作
          doBind0(regFuture, channel, localAddress, promise);
          return promise;
      } else {
          // Registration future is almost always fulfilled already, but just in case it's not.
          final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);
          regFuture.addListener(new ChannelFutureListener() {
              @Override
              public void operationComplete(ChannelFuture future) throws Exception {
                  Throwable cause = future.cause();
                  if (cause != null) {
                      // 管道启动失败后设置失败原因
                      promise.setFailure(cause);
                  } else {
                      // 启动成功
                      promise.registered();
                      // 执行端口的绑定操作
                      doBind0(regFuture, channel, localAddress, promise);
                  }
              }
          });
          return promise;
      }
  }
```

- init()：方法调用的是 ServerBootstrap 复写的方法，其中指定了一些配置后就创建了一个 **ChannelInitializer** 用于在客户端链接到来时，将对应的channel注册到workGroup中来处理对应的读写数据
- config().group().register(channel)：用于将管道注册到bossGroup来监听客户端链接事件

```java
final ChannelFuture initAndRegister() {
        Channel channel = null;
        try {
            //创建主线程的管道，根据管道的类型通过工厂对象进行创建，目前使用的是 NioServerSocketChannel，默认工厂对象使用ReflectiveChannelFactory
            channel = channelFactory.newChannel();
            /**
             * 初始化管道，其中会在实现类 ServerBootstrap 中添加一个 ChannelInitializer类型用于绑定管道处理器
             * 在主线程组中添加了一个 ServerBootstrapAcceptor 的处理器，用于在客户端连接到来时绑定指定的管道处理器
             * 使用的ChannelHandler的子实现 DefaultChannelHandlerContext
             */
            init(channel);
        } catch (Throwable t) {
            if (channel != null) {
                channel.unsafe().closeForcibly();
                return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);
            }
            return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);
        }
        /**
         * 在 NioEventLoopGroup实现了 MultithreadEventLoopGroup 中绑定一个端口监听的任务，注册管道跟 EventLoop 进行关联
         * 这里一般使用的是 NioEventLoopGroup 继承至  MultithreadEventLoopGroup
         */
        ChannelFuture regFuture = config().group().register(channel);
        if (regFuture.cause() != null) {
            if (channel.isRegistered()) {
                channel.close();
            } else {
                channel.unsafe().closeForcibly();
            }
        }
        return regFuture;
    }
```

```java
/**
     * 初始化管道服务，先调用 bind() 绑定端口号，bind() 方法中再调用 init() 方法注册管道的处理器
     *
     * @param channel 这里指定使用的管道类型，一般为 NioServerSocketChannel
     */
    @Override
    void init(Channel channel) {
        //这里设置管道的配置属性
        setChannelOptions(channel, newOptionsArray(), logger);
        setAttributes(channel, newAttributesArray());
        //通过指定管道的类型来创建管道的处理链条，基本上管道都继承 AbstractChannel 这个抽象类，默认创建的pipline类型是 DefaultChannelPipeline
        ChannelPipeline p = channel.pipeline();
        //子线程组
        final EventLoopGroup currentChildGroup = childGroup;
        //子线程处理器
        final ChannelHandler currentChildHandler = childHandler;
        //构建子线程的参数信息
        final Entry<ChannelOption<?>, Object>[] currentChildOptions = newOptionsArray(childOptions);
        //构建子线程的属性
        final Entry<AttributeKey<?>, Object>[] currentChildAttrs = newAttributesArray(childAttrs);
        /**
         * 创建一个 ChannelInitializer 实现了初始化管道方法，在 channel 进行初始化时就会执行，每一个handler都会包装成为一个 DefaultChannelHandlerContext
         * 通过pipline进行添加时，会判断当前pipline是否已经在管道注册完成后执行过（registered属性），如果没有注册都会被包装成 PendingHandlerCallback 任务等待
         * 管道初始化注册后在执行handler的添加事件 handlerAdded()
         */
        p.addLast(new ChannelInitializer<Channel>() {
            @Override
            public void initChannel(final Channel ch) {
                //获取到 DefaultChannelPipeline
                final ChannelPipeline pipeline = ch.pipeline();
                //获取到父级的handler处理器，一般都是为空的
                ChannelHandler handler = config.handler();
                if (handler != null) {
                    pipeline.addLast(handler);
                }
                //添加一个线程任务，用于绑定子线程的 ChannelHandler
                ch.eventLoop().execute(new Runnable() {
                    @Override
                    public void run() {
                        //创建一个 ServerBootstrapAcceptor 接收器，会把配置的 childHandler 注册到父级的pipline中
                        pipeline.addLast(new ServerBootstrapAcceptor(
                                ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));
                    }
                });
            }
        });
    }
```

### 1.2 NioEventLoopGroup

管道注册到bossGroup中进行客户端连接的监听，我们这里使用的是**NioEventLoopGroup** 来进行处理，通过依赖关系可以看到调用 **register方法** 最终是由 **MultithreadEventLoopGroup** 来实现的方法

> ```java
> ChannelFuture regFuture = config().group().register(channel)
> ```

![image-20241023170841658](images/image-20241023170841658.png)

**NioEventLoopGroup.register()** 方法又会创建一个 **NioEventloop** 对象来注册对应的管道，也是实际执行的线程任务，next()方法调用到父类中的chooer属性来选择bossGorup中管理的 **EventExecutor** 事件执行器

```java
public abstract class MultithreadEventExecutorGroup extends AbstractEventExecutorGroup {
    //创建的 NioEventLoop 实现循环对象，一个Group管理多个
    private final EventExecutor[] children;
    //设置为只读
    private final Set<EventExecutor> readonlyChildren;
    //创建所有任务完成操作的任务数量
    private final AtomicInteger terminatedChildren = new AtomicInteger();
    //创建一个所有任务完成的监听器，在完成之后执行状态值的变更
    private final Promise<?> terminationFuture = new DefaultPromise(GlobalEventExecutor.INSTANCE);
    /**
     * 这里根据创建的个数来选择创建选择器
     * 实现类有两个：
     * PowerOfTwoEventExecutorChooser
     * GenericEventExecutorChooser
     */
    private final EventExecutorChooserFactory.EventExecutorChooser chooser;
}
```

```java
public ChannelFuture register(Channel channel) {
    /**
     * 调用父类的方法获取到 EventExecutorChooserFactory.EventExecutorChooser 类型，这里会根据线程的数量进行创建，
     * 默认传的是0，然后会进行计算  Math.max(1, 处理器 * 2)
     * 实现类的类型
     * GenericEventExecutorChooser
     * PowerOfTwoEventExecutorChooser：线程长度超过2创建
     * next() 方法返回的是 EventExecutor接口类型，实现类型是 NioEventLoop 继承至 SingleThreadEventLoop
     */
    return next().register(channel);
}
```

![1667205647926](images/1667205647926-9751404.png)

### 1.3 NioEventLoop

NioEventLoopGroup创建出NioEventLoop对象来进行管道的注册和事件的处理，调用 **NioMessageUnsafe.register()**

```java
public final class NioEventLoop extends SingleThreadEventLoop { 
  	/**
     * 包装之后的Selector：SelectedSelectionKeySetSelector
     * 通过 UNSAFE修改偏移量的方式修改了其中的属性 selectedKeys 来替换为 SelectedSelectionKeySet，这样每次到来事件优先存入到了数组当中也就是selectedKeys属性
     */
    private Selector selector;
    //未包装过的Selector
    private Selector unwrappedSelector;
    /**
     * 提前创建的key集合，保存待处理的key，
     */
    private SelectedSelectionKeySet selectedKeys;
  	//Selector支持器
    private final SelectorProvider provider;
  	/**
     * 选择策略
     * SELECT：获取是否有任务进行执行，并且调整select的阻塞策略
     * CONTINUE：进行下一次的循环
     * BUSY_WAIT：自旋，NIO不支持
     */
    private final SelectStrategy selectStrategy;
}

public abstract class SingleThreadEventLoop extends SingleThreadEventExecutor implements EventLoop {
  
    //调用到 SingleThreadEventLoop
  public ChannelFuture register(final ChannelPromise promise) {
      ObjectUtil.checkNotNull(promise, "promise");
      //这里会调用到 NioServerSocketChannel.newUnsafe()方法创建一个 NioMessageUnsafe对象
      promise.channel().unsafe().register(this, promise);
      return promise;
  }
}

public abstract class SingleThreadEventExecutor extends AbstractScheduledEventExecutor implements OrderedEventExecutor {
  //当前EventLoop绑定的线程，doStartThread()方法中进行绑定的
  	private volatile Thread thread;
   //默认线程池ThreadPerTaskExecutor
    private final Executor executor;
}

```

### 1.4 NioMessageUnsafe

通过依赖图可以看到我们指定的 **NioServerSocketChannel** 继承的路线，创建 **Unsafe** 类则是由 **AbstractNioMessageCahnnel** 中的 **newUnsafe()** 方法创建的类型为 **NioMessageUnsafe**

![依赖图](images/image-20241023172159798.png)

NioEventLoop调用管道中的Unsafe对象来进行注册，用到Unsafe实现类为**NioMessageUnsafe**中没有实现**register()** 方法，调用到 **AbstractChannel#AbstractUnsafe内部类的register方法**

```java
public abstract class SingleThreadEventLoop extends SingleThreadEventExecutor implements EventLoop {
  
    //调用到 SingleThreadEventLoop
  public ChannelFuture register(final ChannelPromise promise) {
      ObjectUtil.checkNotNull(promise, "promise");
      //这里会调用到 NioServerSocketChannel.newUnsafe()方法创建一个 NioMessageUnsafe对象
      promise.channel().unsafe().register(this, promise);
      return promise;
  }
}
```

register方法绑定了一下AbstractChannel中的EventLoop对象，然后提交异步任务执行 **register0()**，**注意：register0()是创建Nio管道的异步任务，会在NioEventLoop.run()异步任务中执行**

```java
public final void register(EventLoop eventLoop, final ChannelPromise promise) {
            ObjectUtil.checkNotNull(eventLoop, "eventLoop");
            //当前管道是否已经被注册了
            if (isRegistered()) {
                promise.setFailure(new IllegalStateException("registered to an event loop already"));
                return;
            }
            //判断是否是 NioEventLoop，只处理 NioEventLoop类型的事件
            if (!isCompatible(eventLoop)) {
                promise.setFailure(
                        new IllegalStateException("incompatible event loop type: " + eventLoop.getClass().getName()));
                return;
            }
            //设置当前管道跟对应的 EventLoop对象关联上
            AbstractChannel.this.eventLoop = eventLoop;
            //判断当前线程是否已经有线程在 EventLoop事件循环中执行，这里采用的NioEventLoop类型，继承至 SingleThreadEventExecutor单线程执行器
            if (eventLoop.inEventLoop()) {
                //如果当前线程已经在EventLoop中注册，直接调用注册方法
                register0(promise);
            } else {
                try {
                    /**
                     * 如果没有线程开始执行，这里会创建一个线程并且将任务存放到队列之中然后调用 NioEventGroup.run() 方法开始监听事件
                     * NioEventLoop继承至 SingleThreadEventExecutor，这里调用的execute() 方法在SingleThreadEventExecutor进行复写
                     */
                    eventLoop.execute(new Runnable() {
                        @Override
                        public void run() {
                            register0(promise);
                        }
                    });
                } catch (Throwable t) {
                    logger.warn(
                            "Force-closing a channel whose registration task was not accepted by an event loop: {}",
                            AbstractChannel.this, t);
                    closeForcibly();
                    closeFuture.setClosed();
                    safeSetFailure(promise, t);
                }
            }
        }
```

### 1.5 SingleThreadEventExecutor

**register0()** 方法通过 **eventLoop.execute()** 来进行异步任务的提交，会提交到相应的队列当中等待 **NioEventLoop开始处理事件时在执行注册**，这里是调用到 **NioEventLoop的父类SingleThreadEventExecutor.execute() 方法**

```java
private void execute(Runnable task, boolean immediate) {
        //判断当前执行的线程是否跟EventLoop绑定的线程一样
        boolean inEventLoop = inEventLoop();
        //将任务添加到 taskQueue 队列之中，开启Selector注册的任务也会添加到这里面，也就是调用 register0() 方法
        addTask(task);
        //如果任务不一样，那么直接启动线程，调用 doStartThread() 方法，其中会提交一个任务去执行 SingleThreadEventExecutor.this.run()
        if (!inEventLoop) {
            startThread();
          //是否关闭线程池
            if (isShutdown()) {
                boolean reject = false;
                try {
                  //移除任务
                    if (removeTask(task)) {
                        reject = true;
                    }
                } catch (UnsupportedOperationException e) {
                }
                //拒绝策略
                if (reject) {
                    reject();
                }
            }
        }
        //添加了任务是否立刻唤醒线程进行任务的执行
        if (!addTaskWakesUp && immediate) {
            wakeup(inEventLoop);
        }
    }
```

**startThread()方法内部调用doStartThread()，而doStartThread()方法调用了SingleThreadEventExecutor.this.run()，run()方法交给了子类来实现，也就是NioEventLoop**

- 根据策略来判断selector选择器的阻塞时间
  - selectNowSupplier：selector选择器立即返回一个准备好的事件
  - hasTasks：判断taskQueue队列是否有任务或者tailTask是否有事件
  - 目前根据返回的数据来进行执行的策略：
    - CONTINUE：-2继续进入下一次循环，自旋
    - BUSY_WAIT：-3忙循环，NIO不支持
    - SELECT：-1选择，计算Selector读取时间的阻塞时间
- 计算好速率，根据 **ioRatio** 来判断执行 taskQueue中任务的速度
- 然后循环的处理Selector中的事件

```java
protected void run() {
        int selectCnt = 0;
        for (;;) {
            try {
                int strategy;
                try {
                    /**
                     * 计算执行的策略，会根据 taskQueue 队列中或者判断管道中是否有事件
                     * 根据流程分析下来，当前任务执行时，Nio管道并没有进行注册，任务由 AbstractChannel#AbstractUnsafe.register()方法提交了一个异步任务到taskQueue
                     * 所以这里默认执行会返回0，以下都不会执行
                     */
                    strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());
                    switch (strategy) {
                        //进入自旋
                    case SelectStrategy.CONTINUE:
                        continue;
                        //NIO不支持 BUSY_WAIT，直接切换到 SELECT执行，从管道中获取到事件
                    case SelectStrategy.BUSY_WAIT:
                        // fall-through to SELECT since the busy-wait is not supported with NIO
                    case SelectStrategy.SELECT:
                        //计算下一次事件获取的终止事件
                        long curDeadlineNanos = nextScheduledTaskDeadlineNanos();
                        if (curDeadlineNanos == -1L) {
                            curDeadlineNanos = NONE; // nothing on the calendar
                        }
                        //设置下一次唤醒的纳秒时间
                        nextWakeupNanos.set(curDeadlineNanos);
                        try {
                            //先判断 taskQueue 队列中是否有任务，这里会先获取到开启管道连接的任务，然后才去监听管道里面的事件
                            if (!hasTasks()) {
                                //轮询是否有任务
                                strategy = select(curDeadlineNanos);
                            }
                        } finally {
                            nextWakeupNanos.lazySet(AWAKE);
                        }
                        // fall through
                    default:
                    }
                } catch (IOException e) {
                    // 如果出现IO异常，那么重新开启一个Nio Selector选择器
                    rebuildSelector0();
                    selectCnt = 0;
                    //休眠1秒
                    handleLoopException(e);
                    continue;
                }
                //循环次数进行统计
                selectCnt++;
                //被取消key的计数器
                cancelledKeys = 0;
                needsToSelectAgain = false;
                //获取到io速率，默认的值是50
                final int ioRatio = this.ioRatio;
                boolean ranTasks;
                //如果速率为100，直接执行管道中的事件以及运行所有队列中的任务
                if (ioRatio == 100) {
                    try {
                        if (strategy > 0) {
                            processSelectedKeys();
                        }
                    } finally {
                        // 确保taskQueue中的任务都已经执行了
                        ranTasks = runAllTasks();
                    }
                } else if (strategy > 0) { //这里判断以下上面是否从管道中获取到了事件
                    final long ioStartTime = System.nanoTime();
                    try {
                        //处理事件
                        processSelectedKeys();
                    } finally {
                        // Ensure we always run tasks.
                        final long ioTime = System.nanoTime() - ioStartTime;
                        //执行任务队列中的任务
                        ranTasks = runAllTasks(ioTime * (100 - ioRatio) / ioRatio);
                    }
                } else {
                    //获取到 taskQueue 队列的执行任务，也是这里会执行 AbstractChannel#AbstractUnsafe.register() 注册管道的方法
                    ranTasks = runAllTasks(0); // This will run the minimum number of tasks
                }
            } catch (CancelledKeyException e) {
            } catch (Error e) {
                throw e;
            } catch (Throwable t) {
                //出现异常后休眠1秒再执行
                handleLoopException(t);
            } finally {
                ;
            }
        }
    }
```

上面在循环处理事件时，调用**runAllTasks()**来执行创建Selector的任务。**register0()方法的目的是来创建一个Nio的管道，然后指定对应感兴趣的事件类型，这个事件类型是NioServerSocketChannel在构造方法中指定的类型**

```java
public NioServerSocketChannel(ServerSocketChannel channel) {
    //指定bossGroup线程池处理 OP_ACCEPT事件,指定管道需要监听的事件（readInterestOp属性）
    super(null, channel, SelectionKey.OP_ACCEPT);
    config = new NioServerSocketChannelConfig(this, javaChannel().socket());
}
```

比较核心的代码是 **javaChannel().register(eventLoop().unwrappedSelector(), 0, this);** 他的目的是将当前的管道跟NioEventLoop.Selector的选择器进行关联，这个时候NioEventLoop.run() 就可以监听对应管道中的事件了

```java
private void register0(ChannelPromise promise) {
    try {
        if (!promise.setUncancellable() || !ensureOpen(promise)) {
            return;
        }
        boolean firstRegistration = neverRegistered;
        //执行注册管道的方法，通过java中的NIO注册对应的管道 SelectionKey
        doRegister();
        neverRegistered = false;
        registered = true;

        //调用 handlerAdded() 事件方法
        pipeline.invokeHandlerAddedIfNeeded();
        //将任务状态设置为成功
        safeSetSuccess(promise);
        //调用管道注册的事件，这里会调用 ChannelInitializer抽象类中的 initChannel() 方法开始执行各种handler的注入
        pipeline.fireChannelRegistered();
        // 是否启动成功
        if (isActive()) {
            //是否是第一次注册
            if (firstRegistration) {
                //调用管道启动的事件
                pipeline.fireChannelActive();
            } else if (config().isAutoRead()) {
              //监听指定的事件，bossGroup指定的是OP_ACCEPT类型
                beginRead();
            }
        }
    } catch (Throwable t) {
        // Close the channel directly to avoid FD leak.
        closeForcibly();
        closeFuture.setClosed();
        safeSetFailure(promise, t);
    }
}

//创建Nio的管道进行注册，默认什么事件都不监听
protected void doRegister() throws Exception {
    boolean selected = false;
    for (;;) {
        try {
            //开始管道注册，默认不监听任何的事件，返回的SelectionKey也是初始的，interestOps也为0
            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);
            return;
        } catch (CancelledKeyException e) {
        }
    }
}
//select创建好之后，调用selectionKey.interestOps设置感兴趣的事件
protected void doBeginRead() throws Exception {
    final SelectionKey selectionKey = this.selectionKey;
    if (!selectionKey.isValid()) {
        return;
    }
    readPending = true;
    //这里在默认开启管道监听的时候，监听的ops设置为0，所以这里返回的interestOps也为0
    final int interestOps = selectionKey.interestOps();
    //&上readInterestOp，这里readInterestOp是SelectionKey.OP_ACCEPT
    if ((interestOps & readInterestOp) == 0) {
        //添加监听OP_ACCEPT事件
        selectionKey.interestOps(interestOps | readInterestOp);
    }
}
```

### 1.6 事件处理

**NioEventLoop.run()** 自旋进行事件的处理，这里处理的方式为两支，一种是优化过的方式，一种是按照原有方式直接从Selector中获取事件的方式：

- processSelectedKeysOptimized：前提是 processSelectedKeys不为null，根据前面netty进行Selector创建是，是对原生的Selector进行包装增强过，代码在 **openSelector()** 中，大致的思路就是将 **原生Selector替换为自己实现的SelectedSelectionKeySet类是通过Unsafe直接通过偏移量进行修改的**，每次事件来了之后优先添加到 SelectedSelectionKeySet 中的数组进行保存
- processSelectedKeysPlain：直接从原生Selector中获取到事件进行处理

```java
private void processSelectedKeys() {
    if (selectedKeys != null) {
        processSelectedKeysOptimized();
    } else {
        processSelectedKeysPlain(selector.selectedKeys());
    }
}
```

最终调用处理事件的方法是 **processSelectedKey()**

```java
private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) {
        final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();
  //key是否是有效
        if (!k.isValid()) {
            final EventLoop eventLoop;
            try {
                eventLoop = ch.eventLoop();
            } catch (Throwable ignored) {
                return;
            }
          //事件循环器与管道中的事件循环器是否一样，是否是其他线程创建的
            if (eventLoop == this) {
                unsafe.close(unsafe.voidPromise());
            }
            return;
        }

        try {
            int readyOps = k.readyOps();
            //事件是否是OP_CONNECT连接事件
            if ((readyOps & SelectionKey.OP_CONNECT) != 0) {
                //重新构建管道需要监听的事件类型
                int ops = k.interestOps();
                ops &= ~SelectionKey.OP_CONNECT;
                k.interestOps(ops);
                unsafe.finishConnect();
            }
            //写事件，去刷新缓存中的数据
            if ((readyOps & SelectionKey.OP_WRITE) != 0) {
                ch.unsafe().forceFlush();
            }
          //处理 OP_READ和OP_ACCEPT 读和接受连接事件
            if ((readyOps & (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {
                //处理对应的读事件或者接收事件 NioMessageUnsafe，根据netty的模型，在第一次获取到读请求时，就会将管道注册到 worker group中进行处理
                unsafe.read();
            }
        } catch (CancelledKeyException ignored) {
            unsafe.close(unsafe.voidPromise());
        }
    }
```

**NioMessageUnsafe** 中只实现了一个read()方法来处理当客户端连接请求到来时，将其传递给 **workGroup** 进行处理，上面在进行初始化管道时就已经注册了一个 **ServerBootstrapAcceptor** 类

```java
private final class NioMessageUnsafe extends AbstractNioUnsafe {

        private final List<Object> readBuf = new ArrayList<Object>();

        @Override
        public void read() {
            //服务端触发读事件的时候执行
            assert eventLoop().inEventLoop();
            final ChannelConfig config = config();
            //处理管道
            final ChannelPipeline pipeline = pipeline();
            //ByteBuf分配器，根据配置进行重置
            final RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();
            allocHandle.reset(config);

            boolean closed = false;
            Throwable exception = null;
            try {
                try {
                    do {
                        //将客户端channel进行包装一层，由 io.netty.channel.socket.nio.NioServerSocketChannel.doReadMessages 进行实现，包装的对象为 NioSocketChannel
                        int localRead = doReadMessages(readBuf);
                        if (localRead == 0) {
                            break;
                        }
                        if (localRead < 0) {
                            closed = true;
                            break;
                        }
                        allocHandle.incMessagesRead(localRead);
                    } while (continueReading(allocHandle));
                } catch (Throwable t) {
                    exception = t;
                }
                int size = readBuf.size();
                for (int i = 0; i < size; i ++) {
                    readPending = false;
                    //触发读事件，第一个事件处理时，这里配合 ServerBootstrapAcceptor 将数据的处理事件交给workGroup进行处理（将管道跟真正处理的 workGroup 进行关联）
                    pipeline.fireChannelRead(readBuf.get(i));
                }
                readBuf.clear();
                allocHandle.readComplete();
                //触发主服务的处理链读取完成的事件
                pipeline.fireChannelReadComplete();
                if (exception != null) {
                    closed = closeOnReadError(exception);
                    //触发异常事件
                    pipeline.fireExceptionCaught(exception);
                }
                if (closed) {
                    inputShutdown = true;
                    if (isOpen()) {
                        close(voidPromise());
                    }
                }
            } finally {
                if (!readPending && !config.isAutoRead()) {
                    removeReadOp();
                }
            }
        }
    }


//调用NioServerSocketChannel.doReadMessages，将原生的SocketChannel管道进行包装传递给字类进行处理 NioSocketChannel
protected int doReadMessages(List<Object> buf) throws Exception {
    SocketChannel ch = SocketUtils.accept(javaChannel());

    try {
        if (ch != null) {
            buf.add(new NioSocketChannel(this, ch));
            return 1;
        }
    } catch (Throwable t) {
        logger.warn("Failed to create a new channel from an accepted socket.", t);
        try {
            ch.close();
        } catch (Throwable t2) {
            logger.warn("Failed to close a socket.", t2);
        }
    }
    return 0;
}
```

当客户端的连接执行到了 **unsafe.read();** 调用到上面方法时，就会执行到 **ServerBootstrapAcceptor.read()** 将管道注册到 **workGroup** 上面，整个绑定的流程

```java
public void channelRead(ChannelHandlerContext ctx, Object msg) {
    final Channel child = (Channel) msg;
    //将指定的子处理器，绑定到当前连接客户端的管道中
    child.pipeline().addLast(childHandler);
    setChannelOptions(child, childOptions, logger);
    setAttributes(child, childAttrs);
    try {
        //由子workEventLoop进行具体的执行，netty的模型又是 bossGroup进行接收管道的注册，接收到数据之后再将channel管道跟workGroup进行绑定，由workGroup进行处理
        childGroup.register(child).addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) throws Exception {
                if (!future.isSuccess()) {
                    forceClose(child, future.cause());
                }
            }
        });
    } catch (Throwable t) {
        forceClose(child, t);
    }
}
```

注意 **childGroup.register(child)** 子管道的绑定流程是 **NioSocketChannel** 进行绑定的，他的继承顺序如下

![image-20241025104436041](images/image-20241025104436041.png)

**AbstractNioByteChannel** 构造方法中指定了当前管道需要监听的事件，客户端创建的 **Unsfae** 也不一样，使用的是 **NioByteUnsafe**，当服务端接收到了客户端的连接后，就会按照客户端的方式进行注册

```java
protected AbstractNioByteChannel(Channel parent, SelectableChannel ch) {
    super(parent, ch, SelectionKey.OP_READ);
}
```

## 2. 客户端启动流程

客户端的启动流程用到的启动器则是 **Bootstrap** 跟服务端继承的类是一样的，只是通过泛型进行区分

```java
public class Bootstrap extends AbstractBootstrap<Bootstrap, Channel> { 

}
```

连接客户端，初始化管道并且注册跟服务端一致，调用的是 **AbstractBootstrap.initAndRegister()**

```java
private ChannelFuture doResolveAndConnect(final SocketAddress remoteAddress, final SocketAddress localAddress) {
        //初始化管道，调用父类
        final ChannelFuture regFuture = initAndRegister();
        final Channel channel = regFuture.channel();
        //管道初始化是否成功
        if (regFuture.isDone()) {
            if (!regFuture.isSuccess()) {
                return regFuture;
            }
            //解析地址并且连接对方
            return doResolveAndConnect0(channel, remoteAddress, localAddress, channel.newPromise());
        } else {
            final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);
            regFuture.addListener(new ChannelFutureListener() {
                @Override
                public void operationComplete(ChannelFuture future) throws Exception {
                    Throwable cause = future.cause();
                    if (cause != null) {
                        promise.setFailure(cause);
                    } else {
                        promise.registered();
                        doResolveAndConnect0(channel, remoteAddress, localAddress, promise);
                    }
                }
            });
            return promise;
        }
    }
```

初始化和注册的流程与服务端一致，只不过用到的管道类和Unsafe通讯类不一样，客户端用到的是 **NioSocketChannel 和 NioByteUnsafe**

```java
private ChannelFuture doResolveAndConnect0(final Channel channel, SocketAddress remoteAddress,
                                               final SocketAddress localAddress, final ChannelPromise promise) {
    try {
        final EventLoop eventLoop = channel.eventLoop();
        AddressResolver<SocketAddress> resolver;
        try {
            //使用DefaultAddressResolverGroup去解析EventLoop应该使用哪个解析器来解析地址
            resolver = this.resolver.getResolver(eventLoop);
        } catch (Throwable cause) {
            channel.close();
            return promise.setFailure(cause);
        }
        //当前解析器是否支持当前的地址或者判断当前地址是否已经被解析过
        if (!resolver.isSupported(remoteAddress) || resolver.isResolved(remoteAddress)) {
            //如果不支持或者已经被解析过，直接进行连接
            doConnect(remoteAddress, localAddress, promise);
            return promise;
        }
        final Future<SocketAddress> resolveFuture = resolver.resolve(remoteAddress);
        if (resolveFuture.isDone()) {
            final Throwable resolveFailureCause = resolveFuture.cause();

            if (resolveFailureCause != null) {
                // Failed to resolve immediately
                channel.close();
                promise.setFailure(resolveFailureCause);
            } else {
                //远程地址解析成功直接连接
                doConnect(resolveFuture.getNow(), localAddress, promise);
            }
            return promise;
        }
        //添加一个监听器等待地址解析完成后进行连接
        resolveFuture.addListener(new FutureListener<SocketAddress>() {
            @Override
            public void operationComplete(Future<SocketAddress> future) throws Exception {
                if (future.cause() != null) {
                    channel.close();
                    promise.setFailure(future.cause());
                } else {
                    doConnect(future.getNow(), localAddress, promise);
                }
            }
        });
    } catch (Throwable cause) {
        promise.tryFailure(cause);
    }
    return promise;
}

//doConnect方法就是通过channel管道中的NioEventLoop提交一个异步任务去连接远程地址
private static void doConnect(
            final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise connectPromise) {
      final Channel channel = connectPromise.channel();
      channel.eventLoop().execute(new Runnable() {
          @Override
          public void run() {
              if (localAddress == null) {
                //channel.connect方法点击进去发现是通过pipline.connect()进行调用的，然后可以看到是通过tail.connect()进行远程的调用，从尾部的处理链条（netty的handler是一个链条数据结构）向前进行调用
                  channel.connect(remoteAddress, connectPromise);
              } else {
                  channel.connect(remoteAddress, localAddress, connectPromise);
              }
              connectPromise.addListener(ChannelFutureListener.CLOSE_ON_FAILURE);
          }
      });
  }
```

**channel.connect() **方法点击进去发现是通过**pipline.connect()**进行调用的，然后可以看到是通过**tail.connect()**进行远程的调用，从尾部的处理链条（netty的handler是一个链条数据结构）向前进行调用，也就是说调用整个处理链中实现了**connect()** 方法的处理类，通过整个处理链的分析，实际上调用到了**HeadContext.connect()** 方法。

**注意：netty创建pipline处理链时，会默认给链条头部创建一个HeadContext和尾部创建一个TailContext 类来实现入栈和出栈的最后一次处理，具体的源码后续解析**

通过 **channel.connect()** 源码进行追溯最终是调用到了 HeadContext.connect() 的方法中，由**unsafe.connect()**来进行连接处理

```java
//HeadContext定义在DefaultChannelPipeline当中
public void connect(
        ChannelHandlerContext ctx,
        SocketAddress remoteAddress, SocketAddress localAddress,
        ChannelPromise promise) {
    unsafe.connect(remoteAddress, localAddress, promise);
}

//执行连接 unsafe.connect
public final void connect(
                final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise) {
    try {
        boolean wasActive = isActive();
      //执行连接，调用 NioSocketChannel.doConnect()中
        if (doConnect(remoteAddress, localAddress)) {
            fulfillConnectPromise(promise, wasActive);
        } else {
            //创建一个定时任务来判断连接是否成功，判断连接是否超时
        }
    } catch (Throwable t) {
        promise.tryFailure(annotateConnectException(t, remoteAddress));
        closeIfClosed();
    }
}
```

直接通过指定的地址去进行连接，然后监听 **OP_CONNECT** 事件，这个时候监听完成之后，就可以回到 **NioEventLoop.run()** 的方法中进行对应的事件处理了

```java
protected boolean doConnect(SocketAddress remoteAddress, SocketAddress localAddress) throws Exception {
    if (localAddress != null) {
        doBind0(localAddress);
    }
    boolean success = false;
    try {
        //javaChannel()是由 NioSocketChannel.newChannel() 方法创建的SocketChannel套接字管道
        boolean connected = SocketUtils.connect(javaChannel(), remoteAddress);
        if (!connected) {
            // 注册connect事件
            selectionKey().interestOps(SelectionKey.OP_CONNECT);
        }
        success = true;
        return connected;
    } finally {
        if (!success) {
            doClose();
        }
    }
}
```

## 3. 事件处理

回到 **NioEventLoop** 中的事件处理方法 **processSelectedKey()**。都是通过unsafe类进行调用，下面分为服务端和客户端的流程进行说明

- 服务端：调用 NioMessageUnsafe，将客户端的连接交给了 ServerBootstrapAcceptor 进行子管道的注册，然后走同样的注册流程
- 客户端：调用NioByteUnsafe，直接从channel管道中读取字节数据包装成Bytebuf类交给后续pipline进行对应的处理

```java
private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) {
        final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();
    try {
        int readyOps = k.readyOps();
        if ((readyOps & SelectionKey.OP_CONNECT) != 0) {
            int ops = k.interestOps();
            //取消监听 OP_CONNECT 事件，先通过取反运算符取消指定位的监听，然后在跟原来的进行取模运算实现取消指定位监听
            ops &= ~SelectionKey.OP_CONNECT;
            //重试设置感兴趣的事件
            k.interestOps(ops);
            //调用finishConnect()方法
            unsafe.finishConnect();
        }
        //写事件，需要先释放一下缓冲区中的数据
        if ((readyOps & SelectionKey.OP_WRITE) != 0) {
            ch.unsafe().forceFlush();
        }
        if ((readyOps & (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {
            //处理对应的读事件或者接收事件，这里接收事件处理时服务端用 NioMessageUnsafe，客户端用 NioByteUnsafe ，根据netty的模型，在第一次获取到读请求时，就会将管道注册到 worker group中进行处理
            unsafe.read();
        }
    } catch (CancelledKeyException ignored) {
        unsafe.close(unsafe.voidPromise());
    }
}
```

